import { Node, Position } from './Node.js';
import { Edge } from './Edge.js';
import { SessionKeyPermission } from './SessionKeyPermission.js';
import { Note } from './Note.js';
import { WorkflowSettings } from '../constants/WorkflowSettings.js';
export type WorkflowState = 'inactive' | 'active' | 'failed' | 'completed' | 'waiting';
export declare class Workflow {
    id: string | null;
    name: string;
    nodes: Node[];
    edges: Edge[];
    state: WorkflowState;
    dateCreated: string | null;
    dateModified: string | null;
    executionId: string | null;
    agentId: string | null;
    notes: Note[];
    settings: WorkflowSettings | null;
    constructor(name?: string, nodes?: Node[], edges?: Edge[], settings?: WorkflowSettings | null);
    setName(name: string): void;
    setSettings(settings: WorkflowSettings | null): void;
    addNode(node: Node): void;
    addNodes(nodes: Node[]): void;
    getNode(ref: string): Node | null;
    deleteNode(nodeToDelete: Node): void;
    /**
     * Inserts a new node into the workflow, potentially splitting an existing edge.
     *
     * - If `nodeAfter` is specified, we expect an edge nodeBefore->nodeAfter to exist.
     *   That edge is removed, and replaced by two new edges:
     *      nodeBefore->nodeToInsert (with `edgeLabelBefore`, `edgeValueBefore`)
     *      nodeToInsert->nodeAfter  (with `edgeLabelAfter`, `edgeValueAfter`)
     *
     * - If `nodeAfter` is not specified, we create only one edge:
     *      nodeBefore->nodeToInsert (with `edgeLabelBefore`, `edgeValueBefore`)
     *
     * SPECIAL CASE: If `nodeBefore` is a trigger and there are other triggers in the workflow,
     * the new node will be connected to ALL triggers in the workflow, not just `nodeBefore`.
     *
     * @param nodeToInsert      The node to insert
     * @param nodeBefore        The existing node that precedes `nodeToInsert`
     * @param nodeAfter         (Optional) The existing node that should follow `nodeToInsert`
     * @param edgeLabelBefore   (Optional) Label for the edge nodeBefore->nodeToInsert
     * @param edgeValueBefore   (Optional) Value for the edge nodeBefore->nodeToInsert
     * @param edgeLabelAfter    (Optional) Label for the edge nodeToInsert->nodeAfter
     * @param edgeValueAfter    (Optional) Value for the edge nodeToInsert->nodeAfter
     */
    insertNode(nodeToInsert: Node, nodeBefore: Node, nodeAfter?: Node, edgeLabelBefore?: string | null, edgeValueBefore?: any | null, edgeLabelAfter?: string | null, edgeValueAfter?: any | null): void;
    insertCondition(nodeToInsert: Node, nodeBefore: Node, nodeAfter?: Node, addElseCase?: boolean, addEmptyNodes?: boolean): void;
    /**
     * Inserts a "split" node, creating `numberOfBranches` parallel branches.
     *
     * If `nodeAfter` is given, we call `insertNode(...)` to splice the split node
     * between `nodeBefore` and `nodeAfter`. That yields two edges:
     *    nodeBefore->nodeToInsert and nodeToInsert->nodeAfter
     * The first branch is effectively "nodeAfter."
     * Then we add additional empty blocks for the remaining branches.
     *
     * If `nodeAfter` is NOT given, we just insertNode(split, nodeBefore),
     * which yields an edge: nodeBefore->split.
     * Then we create `numberOfBranches` empty blocks off the split node.
     *
     * @param nodeToInsert     The split node to insert (e.g. type="Split").
     * @param nodeBefore       The node after which the split is inserted.
     * @param nodeAfter        (Optional) If we're splitting in the middle of a flow, the node that was originally after `nodeBefore`.
     * @param numberOfBranches The total number of branches to create from `nodeToInsert`.
     */
    insertSplit(nodeToInsert: Node, nodeBefore: Node, nodeAfter: Node | undefined, numberOfBranches: number): void;
    swapNode(oldNode: Node, newNode: Node): void;
    addEdge(edge: Edge): void;
    updateEdge(edgeId: string, newEdge: Edge): void;
    addEdges(edges: Edge[]): void;
    /**
   * Gets all outgoing edges from a given node.
   * @param node The source node to get edges from
   * @returns Array of edges that have the given node as their source
   */
    getEdges(node: Node): Edge[];
    getState(): WorkflowState;
    addNote(note: Note): void;
    updateNote(noteId: string, newText: string, newPosition: Position): void;
    deleteNote(noteId: string): void;
    getNotes(): {
        id: string | null;
        text: string;
        position: Position;
    }[];
    toJSON(): {
        id: string | null;
        name: string;
        state: WorkflowState;
        dateCreated: string | null;
        dateModified: string | null;
        executionId: string | null;
        agentId: string | null;
        nodes: {
            [key: string]: any;
        }[];
        edges: {
            [key: string]: any;
        }[];
        notes: {
            id: string | null;
            text: string;
            position: Position;
        }[];
        settings: WorkflowSettings | null;
    };
    create(): Promise<{
        success: boolean;
        error?: string;
    }>;
    update(): Promise<{
        success: boolean;
        error?: string;
    }>;
    load(workflowId: string): Promise<Workflow>;
    reload(): Promise<Workflow>;
    run(): Promise<{
        success: boolean;
        error?: string;
    }>;
    delete(): Promise<{
        success: boolean;
        error?: string;
    }>;
    getSessionKeyPermissions(): Promise<SessionKeyPermission>;
    getEndNodePositions(): {
        x: number;
        y: number;
    }[];
    /**
     * Validates all internal variable references in node parameters.
     * An internal variable reference is a string that starts with "nodeMap." followed by a node ref.
     * Example: "nodeMap.1.output.amount" references node with ref "1"
     *
     * @returns Array of invalid parameter references with their node and parameter info
     */
    validateInternalVariables(): Array<{
        nodeRef: string;
        nodeType: string;
        parameterKey: string;
        parameterValue: string;
        referencedNodeRef: string;
    }>;
    static fromJSON(json: any): Promise<Workflow>;
}
