import { ethers } from 'ethers';
import { CHAINS } from '../constants/chains.js';
class RPCServices {
    constructor() {
        this.rpcUrls = {}; // Store the RPC URLs
    }
    // Function to set RPC URLs
    setRPCs(rpcs) {
        this.rpcUrls = { ...this.rpcUrls, ...rpcs };
    }
    setRPCsFromTMS(env) {
        if (env.MODE_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.MODE] = env.MODE_HTTPS_PROVIDER;
        }
        if (env.INFURA_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.ETHEREUM] = env.INFURA_HTTPS_PROVIDER;
        }
        if (env.ABSTRACT_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.ABSTRACT] = env.ABSTRACT_HTTPS_PROVIDER;
        }
        if (env.ARBITRUM_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.ARBITRUM] = env.ARBITRUM_HTTPS_PROVIDER;
        }
        if (env.OASIS_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.OASIS] = env.OASIS_HTTPS_PROVIDER;
        }
        if (env.AVALANCHE_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.AVALANCHE] = env.AVALANCHE_HTTPS_PROVIDER;
        }
        if (env.SONIC_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.SONIC] = env.SONIC_HTTPS_PROVIDER;
        }
        if (env.OPTIMISM_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.OPTIMISM] = env.OPTIMISM_HTTPS_PROVIDER;
        }
        if (env.POLYGON_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.POLYGON] = env.POLYGON_HTTPS_PROVIDER;
        }
        if (env.BINANCE_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.BINANCE] = env.BINANCE_HTTPS_PROVIDER;
        }
        if (env.SOMNIA_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.SOMNIA] = env.SOMNIA_HTTPS_PROVIDER;
        }
        if (env.HYPER_EVM_HTTPS_PROVIDER) {
            this.rpcUrls[CHAINS.HYPER_EVM] = env.HYPER_EVM_HTTPS_PROVIDER;
        }
    }
    // Function to get the RPC URL for a specific chainId
    getRPC(chainId) {
        const rpcUrl = this.rpcUrls[chainId];
        if (!rpcUrl) {
            throw new Error(`No RPC URL configured for chain ID ${chainId}`);
        }
        return rpcUrl;
    }
    // Function to fetch token details from the blockchain
    async getTokenDetails(chainId, contractAddress) {
        const rpcUrl = this.getRPC(chainId); // Get the RPC URL for the chain
        const provider = new ethers.JsonRpcProvider(rpcUrl);
        // Define the contract ABI for the read-only functions (decimals, name, symbol)
        const erc20ABI = [
            'function decimals() view returns (uint8)',
            'function name() view returns (string)',
            'function symbol() view returns (string)',
        ];
        const contract = new ethers.Contract(contractAddress, erc20ABI, provider);
        const maxRetries = 3; // Max number of retries
        const retryDelay = (attempt) => Math.pow(2, attempt) * 1000; // Exponential backoff delay (in milliseconds)
        // Define a helper function to retry the RPC call
        const fetchWithRetry = async (fn, retries) => {
            let attempt = 0;
            while (attempt <= retries) {
                try {
                    const result = await fn();
                    if (typeof result === 'bigint') {
                        return +(result.toString());
                    }
                    return result;
                }
                catch (error) {
                    if (attempt === retries) {
                        throw new Error(`Error fetching token details ${contractAddress} on chain ${chainId}`);
                    }
                    attempt++;
                    // console.warn(`Attempt ${attempt} to fetch token details failed. Retrying in ${retryDelay(attempt)}ms...`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay(attempt)));
                }
            }
            throw new Error('Max retries exceeded');
        };
        // Fetch the decimals, name, and symbol with retries
        try {
            const [decimals, name, symbol] = await Promise.all([
                fetchWithRetry(() => contract.decimals(), maxRetries),
                fetchWithRetry(() => contract.name(), maxRetries),
                fetchWithRetry(() => contract.symbol(), maxRetries),
            ]);
            const token = {
                contractAddress,
                symbol,
                name,
                decimals,
                image: null,
            };
            return token;
        }
        catch (error) {
            throw new Error(`Error fetching token details: ${error.message}`);
        }
    }
}
// Export RPC services instance
export const rpcServices = new RPCServices();
