import axios from 'axios';
const API_CONFIG = {
    BASE_URL: 'https://api.otomato.xyz/api',
    HEADERS: {
        'Content-Type': 'application/json',
    }
};
const axiosInstance = axios.create({
    baseURL: API_CONFIG.BASE_URL,
    headers: API_CONFIG.HEADERS
});
class ApiServices {
    constructor() {
        this.auth = null;
    }
    setAuth(auth) {
        this.auth = auth;
    }
    setUrl(baseUrl) {
        axiosInstance.defaults.baseURL = baseUrl;
    }
    async post(url, data) {
        const headers = this.auth ? { 'Authorization': this.auth } : {};
        return await axiosInstance.post(url, data, { headers });
    }
    async patch(url, data) {
        const headers = this.auth ? { 'Authorization': this.auth } : {};
        return await axiosInstance.patch(url, data, { headers });
    }
    async put(url, data) {
        const headers = this.auth ? { 'Authorization': this.auth } : {};
        return await axiosInstance.put(url, data, { headers });
    }
    async get(url) {
        const headers = this.auth ? { 'Authorization': this.auth } : {};
        const response = await axiosInstance.get(url, { headers });
        return response.data;
    }
    async delete(url) {
        const headers = this.auth ? { 'Authorization': this.auth } : {};
        return await axiosInstance.delete(url, { headers });
    }
    async generateLoginPayload(address, chainId, referralCode, ownerWalletAddress) {
        const headers = { 'Content-Type': 'application/json' };
        const response = await axiosInstance.post('/auth/generate-payload', { address, chainId, referralCode, ownerWalletAddress }, { headers });
        return response.data;
    }
    async getToken(loginPayload, signature) {
        const headers = { 'Content-Type': 'application/json' };
        const body = {
            payload: loginPayload,
            signature,
        };
        const response = await axiosInstance.post('/auth/token', body, { headers });
        const token = response.data.token;
        return { token };
    }
    async verifyToken(token) {
        const headers = { 'Content-Type': 'application/json' };
        const response = await axiosInstance.post('/auth/verify-token', { token }, { headers });
        return response.data;
    }
    async getWorkflowsOfUser(offset, limit, isActive, query) {
        if (!this.auth) {
            throw new Error('Authorization token is required');
        }
        const headers = { 'Authorization': this.auth };
        // Set defaults for offset and limit if not provided
        const finalOffset = offset ?? 0;
        const finalLimit = limit ?? 8;
        const params = new URLSearchParams();
        params.append('offset', finalOffset.toString());
        params.append('limit', finalLimit.toString());
        // Add isActive filter if provided
        if (isActive !== undefined) {
            params.append('isActive', isActive.toString());
        }
        // add a query to filter by name
        if (query) {
            params.append('q', query);
        }
        const url = `/workflows?${params.toString()}`;
        const response = await axiosInstance.get(url, { headers });
        return response.data;
    }
    async getSessionKeyPermissions(workflowId) {
        if (!this.auth) {
            throw new Error('Authorization token is required');
        }
        try {
            const url = `/workflows/${workflowId}/verify-contracts`;
            const headers = { Authorization: this.auth };
            const response = await axiosInstance.post(url, {}, { headers });
            return response.data; // Return the data from the response
        }
        catch (error) {
            console.error('Error verifying contracts:', error.response?.data || error.message);
            throw new Error(error.response?.data?.message || 'Failed to verify contracts');
        }
    }
}
export const apiServices = new ApiServices();
